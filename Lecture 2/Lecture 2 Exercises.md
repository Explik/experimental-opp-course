# Lecture 2 exercises

## Exercise 1
A simple Person class has been provided.
```C#
class Person 
{
  string FirstName; 
  string LastName;
  int Age;
}
```

**1A)** Rewrite the private fields into public properties, add initial values and add validation. 

Initial values: 
- FirstName should be initialised as “Unknown”
- LastName should be initialised as “Unknown”

Validation criteria: 
- FirstName & LastName cannot be null
- FirstName & LastName cannot be empty 
- FirstName & LastName can only include the characters a - z
- FirstName & LastName cannot be longer than 100 characters 
- Age cannot be negative

- Do not change property value if criteria are not fulfilled 

**1B)** Add the properties Mother and Father to Person, each with the same properties as their child, and add validation. 

Initial values: 
- Mother should be initialized as null
- Father should be initialized as null

Validation criterion: 
- Mother & Father cannot be younger than the person self

Do not change property value if criteria are not fulfilled 

**1C)** Add a method GeneratePerson to PersonGenerator. This method should return a new Person with the first name Adam, last name Smith and age 36.  

**1D)** Add a method GenerateFamily to PersonGenerator. This method should return a person with the family tree below. *Hint: Association*

Insert image here :)

**1E)** Add a new instance method void PrintPerson(Person p) to PersonPrinter. Given the object generated by PersonGenerator.GeneratePerson(), it should produce the output below. 
```
Adam Smith (36)
```

**1F)** Add a new instance method PrintFamily to PersonPrinter. Given the object generate by PersonGenerator.GenerateFamily, it should produce the output below. *Hint: Recursion.*

**1G)** Add an additional constructor to Person, which allows you to assign parents before the construction of a new Person. Hint: Remember the default constructor.

**1H)** Add a new read-only property ID to Person. ID should be a unique identifier, which increases by 1 for each new Person. *Hint: Static class members*   


## Exericse 2 
A simple (mutable) Number class has been provided.
```C#
class Number 
{
  int Value; 
}
```
**2A)** Rewrite the field Value into a public read-only property.

**2B)** Add a constructor to Number, which requires you to assign Value before the construction of a new Number. 

**2C)** Add the methods below to the Number objects, which all take another Number and store the result in the original Value. *Hint: Mutable object*

Methods: 
- Add (+)
- Subtract (-)
- Multiply (*)

## Exercise 3
A simple (immutable) Number class has been provided.
```C#
class ImmutableNumber 
{
  int Value;
}
```

**3A)** Rewrite the field Value into a public read-only property.

**3B)** Add a new constructor to Number, which requires you to assign Value on the creation of a new Number. 

**3C)** Add the methods below to the Number objects, which all take another Number and store the result in the value of a new Number. *Hint: Immutable object*

Methods: 
- Add (+)
- Subtract (-)
- Multiply (*)

## Exercise 4
Lookup the difference between a value type and a reference type. 

**4A)** Explain, in your own words, the difference between the two blocks below. 

```C#
int four = 4;
int five1 = 5;
int five2 = 5;

four == five1 -> false
five1 == five2 -> true
```

```C#
Number four = new Number(4);
Number five1 = new Number(5);
Number five2 = new Number(5);

four == five1 -> false
five1 == five2 -> false
```

**4B)** Add a new overridden method Equals to Number, which equates two numbers if they have the same value.
```C#
four.Equals(five1) -> false
five1.Equals(five2) -> true
```

**4C)** Add a new override method GetHashCode to Number, which equates two numbers if they have the same value.
```C#
four.GetHashCode() == five1.GetHashCode() -> false
five1.GetHashCode() == five2.GetHashCode() -> true
```
